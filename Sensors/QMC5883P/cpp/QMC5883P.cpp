/**
 * @file qmc5883p.cpp
 * @brief QMC5883P Magnetometer Sensor Driver Implementation
 * 
 * This file contains the implementation of the QMC5883P class methods
 * for interfacing with the QMC5883P 3-axis magnetometer sensor.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.0
 * @date 2025.11.28
 * 
 * @note Comments are mostly generated by AI
 * 
 * @CHANGELOG:
 * - (See qmc5883p.h for changes)
 * 
 */

#include "qmc5883p.h"

/**
 * @brief Construct a new QMC5883P object
 * 
 * @param hi2c Pointer to I2C handle
 * @param mode Operation mode
 * @param speed Output data rate
 * @param range Measurement range
 */
QMC5883P::QMC5883P(I2C_HandleTypeDef *hi2c, QMC5883P_Mode mode, QMC5883P_Spd speed, QMC5883P_Rng range) :
    _hi2c(hi2c),
    _mode(mode),
    _speed(speed),
    _range(range),
    _mag_x(0.0f),
    _mag_y(0.0f),
    _mag_z(0.0f) {
        
    switch (_range) {
        case QMC5883P_Rng::RNG_2G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_2G;
            break;
        case QMC5883P_Rng::RNG_8G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_8G;
            break;
        case QMC5883P_Rng::RNG_12G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_12G;
            break;
        case QMC5883P_Rng::RNG_30G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_30G;
            break;
    }
}

/**
 * @brief Destroy the QMC5883P object
 */
QMC5883P::~QMC5883P() {}

/**
 * @brief Send data to the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
HAL_StatusTypeDef QMC5883P::_i2cSend(uint8_t reg, uint8_t *data, uint8_t len) {
    return HAL_I2C_Mem_Write(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);
}

/**
 * @brief Receive data from the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
HAL_StatusTypeDef QMC5883P::_i2cRecv(uint8_t reg, uint8_t *data, uint8_t len) {
    return HAL_I2C_Mem_Read(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);
}

/**
 * @brief Check if new data is available
 * 
 * @return true Data is ready
 * @return false Data is not ready
 */
bool QMC5883P::_isDataRdy() {
    uint8_t isReady = 0;

    if (_i2cRecv(QMC5883P_REG_STATUS, &isReady, 1) != HAL_OK) {
        return false;
    }
    return (isReady & QMC5883P_STATUS_DRDY);
}

/**
 * @brief Initialize the QMC5883P sensor
 * 
 * This function performs the following steps:
 * 1. Resets the sensor
 * 2. Verifies the chip ID
 * 3. Configures the measurement range
 * 4. Sets the operation mode and data rate
 * 
 * @return QMC5883P_Status Status of initialization
 */
QMC5883P::QMC5883P_Status QMC5883P::begin() {
    uint8_t data;

    HAL_Delay(10);
    // Reset the sensor
    data = QMC5883P_CONTROL_2_SOFT_RESET;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != HAL_OK) {
        return QMC5883P_Status::ERROR;
    }

    HAL_Delay(20);

    data = 0x00;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != HAL_OK) {
        return QMC5883P_Status::ERROR;
    }

    HAL_Delay(20);

    if (_i2cRecv(QMC5883P_REG_CHIP_ID, &data, 1) != HAL_OK) {
        return QMC5883P_Status::ERROR;        
    }
    if (data != QMC5883P_CHIP_ID) {
        return QMC5883P_Status::ERROR_ID;        
    }

    data = static_cast<uint8_t>(_range);
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != HAL_OK) {
        return QMC5883P_Status::ERROR;
    }

    // Configure the sensor
    data = static_cast<uint8_t>(_mode) | static_cast<uint8_t>(_speed) |
           QMC5883P_CONTROL_1_OSR1_2 | QMC5883P_CONTROL_1_OSR2_2;
    if (_i2cSend(QMC5883P_REG_CONTROL_1, &data, 1) != HAL_OK) {
        return QMC5883P_Status::ERROR;        
    }

    return QMC5883P_Status::OK;
}

/**
 * @brief Read new data from the sensor
 * 
 * This function waits for data to be ready, reads the raw magnetic
 * field data from the sensor, applies calibration offsets and scaling,
 * and stores the calibrated values.
 * 
 * @return QMC5883P_Status Status of data reading
 */
QMC5883P::QMC5883P_Status QMC5883P::update() {
    uint8_t rawData[6];

    uint32_t start = HAL_GetTick();

    while (!_isDataRdy()) {
        if (HAL_GetTick() - start > QMC5883P_READ_TIMEOUT_MS) {
            return QMC5883P_Status::ERROR;
        }
        HAL_Delay(1);
    }

    if (_i2cRecv(QMC5883P_REG_XOUT_L, rawData, 6) != HAL_OK) {
        return QMC5883P_Status::ERROR;
    }

    int16_t raw_x = (int16_t)(rawData[1] << 8 | rawData[0]);
    int16_t raw_y = (int16_t)(rawData[3] << 8 | rawData[2]);
    int16_t raw_z = (int16_t)(rawData[5] << 8 | rawData[4]);

    // Apply calibration offsets and scaling
    _mag_x = ((float)raw_x / (float)_sensitivity - MAG_X_OFFSET) * MAG_X_SCALE;
    _mag_y = ((float)raw_y / (float)_sensitivity - MAG_Y_OFFSET) * MAG_Y_SCALE;
    _mag_z = ((float)raw_z / (float)_sensitivity - MAG_Z_OFFSET) * MAG_Z_SCALE;

    return QMC5883P_Status::OK;
}
